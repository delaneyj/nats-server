// Code generated by bencgen go. DO NOT EDIT.
// source: schema/meta_snapshot.benc

package metasnap

import (
    "github.com/deneonet/benc/std"
    "github.com/deneonet/benc/impl/gen"


)

// Struct - MetaSnapshot
type MetaSnapshot struct {
    Streams []StreamAssignment
}

// Reserved Ids - MetaSnapshot
var metaSnapshotRIds = []uint16{}

// Size - MetaSnapshot
func (metaSnapshot *MetaSnapshot) Size() int {
    return metaSnapshot.NestedSize(0)
}

// Nested Size - MetaSnapshot
func (metaSnapshot *MetaSnapshot) NestedSize(id uint16) (s int) {
    s += bstd.SizeSlice(metaSnapshot.Streams, func (s StreamAssignment) int { return s.SizePlain() }) + 2

    if id > 255 {
        s += 5
        return
    }
    s += 4
    return
}

// SizePlain - MetaSnapshot
func (metaSnapshot *MetaSnapshot) SizePlain() (s int) {
    s += bstd.SizeSlice(metaSnapshot.Streams, func (s StreamAssignment) int { return s.SizePlain() })
    return
}

// Marshal - MetaSnapshot
func (metaSnapshot *MetaSnapshot) Marshal(b []byte) {
    metaSnapshot.NestedMarshal(0, b, 0)
}

// Nested Marshal - MetaSnapshot
func (metaSnapshot *MetaSnapshot) NestedMarshal(tn int, b []byte, id uint16) (n int) {
    n = bgenimpl.MarshalTag(tn, b, bgenimpl.Container, id)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.ArrayMap, 1)
    n = bstd.MarshalSlice(n, b, metaSnapshot.Streams, func (n int, b []byte, s StreamAssignment) int { return s.MarshalPlain(n, b) })

    n += 2
    b[n-2] = 1
    b[n-1] = 1
    return
}

// MarshalPlain - MetaSnapshot
func (metaSnapshot *MetaSnapshot) MarshalPlain(tn int, b []byte) (n int) {
    n = tn
    n = bstd.MarshalSlice(n, b, metaSnapshot.Streams, func (n int, b []byte, s StreamAssignment) int { return s.MarshalPlain(n, b) })
    return n
}

// Unmarshal - MetaSnapshot
func (metaSnapshot *MetaSnapshot) Unmarshal(b []byte) (err error) {
    _, err = metaSnapshot.NestedUnmarshal(0, b, []uint16{}, 0)
    return
}

// Nested Unmarshal - MetaSnapshot
func (metaSnapshot *MetaSnapshot) NestedUnmarshal(tn int, b []byte, r []uint16, id uint16) (n int, err error) {
    var ok bool
    if n, ok, err = bgenimpl.HandleCompatibility(tn, b, r, id); !ok {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, metaSnapshotRIds, 1); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, metaSnapshot.Streams, err = bstd.UnmarshalSlice[StreamAssignment](n, b, func (n int, b []byte, s *StreamAssignment) (int, error) { return s.UnmarshalPlain(n, b) }); err != nil {
            return
        }
    }
    n += 2
    return
}

// UnmarshalPlain - MetaSnapshot
func (metaSnapshot *MetaSnapshot) UnmarshalPlain(tn int, b []byte) (n int, err error) {
    n = tn
    if n, metaSnapshot.Streams, err = bstd.UnmarshalSlice[StreamAssignment](n, b, func (n int, b []byte, s *StreamAssignment) (int, error) { return s.UnmarshalPlain(n, b) }); err != nil {
        return
    }
    return
}

// Struct - StreamAssignment
type StreamAssignment struct {
    Has_client bool
    Client ClientInfo
    Created_unix_nano int64
    Stream_config []byte
    Has_group bool
    Group RaftGroup
    Sync string
    Consumers []ConsumerAssignment
}

// Reserved Ids - StreamAssignment
var streamAssignmentRIds = []uint16{}

// Size - StreamAssignment
func (streamAssignment *StreamAssignment) Size() int {
    return streamAssignment.NestedSize(0)
}

// Nested Size - StreamAssignment
func (streamAssignment *StreamAssignment) NestedSize(id uint16) (s int) {
    s += bstd.SizeBool() + 2
    s += streamAssignment.Client.NestedSize(2)
    s += bstd.SizeInt64() + 2
    s += bstd.SizeBytes(streamAssignment.Stream_config) + 2
    s += bstd.SizeBool() + 2
    s += streamAssignment.Group.NestedSize(6)
    s += bstd.SizeString(streamAssignment.Sync) + 2
    s += bstd.SizeSlice(streamAssignment.Consumers, func (s ConsumerAssignment) int { return s.SizePlain() }) + 2

    if id > 255 {
        s += 5
        return
    }
    s += 4
    return
}

// SizePlain - StreamAssignment
func (streamAssignment *StreamAssignment) SizePlain() (s int) {
    s += bstd.SizeBool()
    s += streamAssignment.Client.SizePlain()
    s += bstd.SizeInt64()
    s += bstd.SizeBytes(streamAssignment.Stream_config)
    s += bstd.SizeBool()
    s += streamAssignment.Group.SizePlain()
    s += bstd.SizeString(streamAssignment.Sync)
    s += bstd.SizeSlice(streamAssignment.Consumers, func (s ConsumerAssignment) int { return s.SizePlain() })
    return
}

// Marshal - StreamAssignment
func (streamAssignment *StreamAssignment) Marshal(b []byte) {
    streamAssignment.NestedMarshal(0, b, 0)
}

// Nested Marshal - StreamAssignment
func (streamAssignment *StreamAssignment) NestedMarshal(tn int, b []byte, id uint16) (n int) {
    n = bgenimpl.MarshalTag(tn, b, bgenimpl.Container, id)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed8, 1)
    n = bstd.MarshalBool(n, b, streamAssignment.Has_client)
    n = streamAssignment.Client.NestedMarshal(n, b, 2)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed64, 3)
    n = bstd.MarshalInt64(n, b, streamAssignment.Created_unix_nano)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 4)
    n = bstd.MarshalBytes(n, b, streamAssignment.Stream_config)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed8, 5)
    n = bstd.MarshalBool(n, b, streamAssignment.Has_group)
    n = streamAssignment.Group.NestedMarshal(n, b, 6)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 7)
    n = bstd.MarshalString(n, b, streamAssignment.Sync)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.ArrayMap, 8)
    n = bstd.MarshalSlice(n, b, streamAssignment.Consumers, func (n int, b []byte, s ConsumerAssignment) int { return s.MarshalPlain(n, b) })

    n += 2
    b[n-2] = 1
    b[n-1] = 1
    return
}

// MarshalPlain - StreamAssignment
func (streamAssignment *StreamAssignment) MarshalPlain(tn int, b []byte) (n int) {
    n = tn
    n = bstd.MarshalBool(n, b, streamAssignment.Has_client)
    n = streamAssignment.Client.MarshalPlain(n, b)
    n = bstd.MarshalInt64(n, b, streamAssignment.Created_unix_nano)
    n = bstd.MarshalBytes(n, b, streamAssignment.Stream_config)
    n = bstd.MarshalBool(n, b, streamAssignment.Has_group)
    n = streamAssignment.Group.MarshalPlain(n, b)
    n = bstd.MarshalString(n, b, streamAssignment.Sync)
    n = bstd.MarshalSlice(n, b, streamAssignment.Consumers, func (n int, b []byte, s ConsumerAssignment) int { return s.MarshalPlain(n, b) })
    return n
}

// Unmarshal - StreamAssignment
func (streamAssignment *StreamAssignment) Unmarshal(b []byte) (err error) {
    _, err = streamAssignment.NestedUnmarshal(0, b, []uint16{}, 0)
    return
}

// Nested Unmarshal - StreamAssignment
func (streamAssignment *StreamAssignment) NestedUnmarshal(tn int, b []byte, r []uint16, id uint16) (n int, err error) {
    var ok bool
    if n, ok, err = bgenimpl.HandleCompatibility(tn, b, r, id); !ok {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, streamAssignmentRIds, 1); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, streamAssignment.Has_client, err = bstd.UnmarshalBool(n, b); err != nil {
            return
        }
    }
    if n, err = streamAssignment.Client.NestedUnmarshal(n, b, streamAssignmentRIds, 2); err != nil {
        return
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, streamAssignmentRIds, 3); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, streamAssignment.Created_unix_nano, err = bstd.UnmarshalInt64(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, streamAssignmentRIds, 4); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, streamAssignment.Stream_config, err = bstd.UnmarshalBytesCropped(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, streamAssignmentRIds, 5); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, streamAssignment.Has_group, err = bstd.UnmarshalBool(n, b); err != nil {
            return
        }
    }
    if n, err = streamAssignment.Group.NestedUnmarshal(n, b, streamAssignmentRIds, 6); err != nil {
        return
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, streamAssignmentRIds, 7); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, streamAssignment.Sync, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, streamAssignmentRIds, 8); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, streamAssignment.Consumers, err = bstd.UnmarshalSlice[ConsumerAssignment](n, b, func (n int, b []byte, s *ConsumerAssignment) (int, error) { return s.UnmarshalPlain(n, b) }); err != nil {
            return
        }
    }
    n += 2
    return
}

// UnmarshalPlain - StreamAssignment
func (streamAssignment *StreamAssignment) UnmarshalPlain(tn int, b []byte) (n int, err error) {
    n = tn
    if n, streamAssignment.Has_client, err = bstd.UnmarshalBool(n, b); err != nil {
        return
    }
    if n, err = streamAssignment.Client.UnmarshalPlain(n, b); err != nil {
        return
    }
    if n, streamAssignment.Created_unix_nano, err = bstd.UnmarshalInt64(n, b); err != nil {
        return
    }
    if n, streamAssignment.Stream_config, err = bstd.UnmarshalBytesCropped(n, b); err != nil {
        return
    }
    if n, streamAssignment.Has_group, err = bstd.UnmarshalBool(n, b); err != nil {
        return
    }
    if n, err = streamAssignment.Group.UnmarshalPlain(n, b); err != nil {
        return
    }
    if n, streamAssignment.Sync, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, streamAssignment.Consumers, err = bstd.UnmarshalSlice[ConsumerAssignment](n, b, func (n int, b []byte, s *ConsumerAssignment) (int, error) { return s.UnmarshalPlain(n, b) }); err != nil {
        return
    }
    return
}

// Struct - ConsumerAssignment
type ConsumerAssignment struct {
    Has_client bool
    Client ClientInfo
    Created_unix_nano int64
    Name string
    Stream string
    Consumer_config []byte
    Has_group bool
    Group RaftGroup
    Has_state bool
    State ConsumerState
}

// Reserved Ids - ConsumerAssignment
var consumerAssignmentRIds = []uint16{}

// Size - ConsumerAssignment
func (consumerAssignment *ConsumerAssignment) Size() int {
    return consumerAssignment.NestedSize(0)
}

// Nested Size - ConsumerAssignment
func (consumerAssignment *ConsumerAssignment) NestedSize(id uint16) (s int) {
    s += bstd.SizeBool() + 2
    s += consumerAssignment.Client.NestedSize(2)
    s += bstd.SizeInt64() + 2
    s += bstd.SizeString(consumerAssignment.Name) + 2
    s += bstd.SizeString(consumerAssignment.Stream) + 2
    s += bstd.SizeBytes(consumerAssignment.Consumer_config) + 2
    s += bstd.SizeBool() + 2
    s += consumerAssignment.Group.NestedSize(8)
    s += bstd.SizeBool() + 2
    s += consumerAssignment.State.NestedSize(10)

    if id > 255 {
        s += 5
        return
    }
    s += 4
    return
}

// SizePlain - ConsumerAssignment
func (consumerAssignment *ConsumerAssignment) SizePlain() (s int) {
    s += bstd.SizeBool()
    s += consumerAssignment.Client.SizePlain()
    s += bstd.SizeInt64()
    s += bstd.SizeString(consumerAssignment.Name)
    s += bstd.SizeString(consumerAssignment.Stream)
    s += bstd.SizeBytes(consumerAssignment.Consumer_config)
    s += bstd.SizeBool()
    s += consumerAssignment.Group.SizePlain()
    s += bstd.SizeBool()
    s += consumerAssignment.State.SizePlain()
    return
}

// Marshal - ConsumerAssignment
func (consumerAssignment *ConsumerAssignment) Marshal(b []byte) {
    consumerAssignment.NestedMarshal(0, b, 0)
}

// Nested Marshal - ConsumerAssignment
func (consumerAssignment *ConsumerAssignment) NestedMarshal(tn int, b []byte, id uint16) (n int) {
    n = bgenimpl.MarshalTag(tn, b, bgenimpl.Container, id)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed8, 1)
    n = bstd.MarshalBool(n, b, consumerAssignment.Has_client)
    n = consumerAssignment.Client.NestedMarshal(n, b, 2)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed64, 3)
    n = bstd.MarshalInt64(n, b, consumerAssignment.Created_unix_nano)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 4)
    n = bstd.MarshalString(n, b, consumerAssignment.Name)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 5)
    n = bstd.MarshalString(n, b, consumerAssignment.Stream)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 6)
    n = bstd.MarshalBytes(n, b, consumerAssignment.Consumer_config)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed8, 7)
    n = bstd.MarshalBool(n, b, consumerAssignment.Has_group)
    n = consumerAssignment.Group.NestedMarshal(n, b, 8)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed8, 9)
    n = bstd.MarshalBool(n, b, consumerAssignment.Has_state)
    n = consumerAssignment.State.NestedMarshal(n, b, 10)

    n += 2
    b[n-2] = 1
    b[n-1] = 1
    return
}

// MarshalPlain - ConsumerAssignment
func (consumerAssignment *ConsumerAssignment) MarshalPlain(tn int, b []byte) (n int) {
    n = tn
    n = bstd.MarshalBool(n, b, consumerAssignment.Has_client)
    n = consumerAssignment.Client.MarshalPlain(n, b)
    n = bstd.MarshalInt64(n, b, consumerAssignment.Created_unix_nano)
    n = bstd.MarshalString(n, b, consumerAssignment.Name)
    n = bstd.MarshalString(n, b, consumerAssignment.Stream)
    n = bstd.MarshalBytes(n, b, consumerAssignment.Consumer_config)
    n = bstd.MarshalBool(n, b, consumerAssignment.Has_group)
    n = consumerAssignment.Group.MarshalPlain(n, b)
    n = bstd.MarshalBool(n, b, consumerAssignment.Has_state)
    n = consumerAssignment.State.MarshalPlain(n, b)
    return n
}

// Unmarshal - ConsumerAssignment
func (consumerAssignment *ConsumerAssignment) Unmarshal(b []byte) (err error) {
    _, err = consumerAssignment.NestedUnmarshal(0, b, []uint16{}, 0)
    return
}

// Nested Unmarshal - ConsumerAssignment
func (consumerAssignment *ConsumerAssignment) NestedUnmarshal(tn int, b []byte, r []uint16, id uint16) (n int, err error) {
    var ok bool
    if n, ok, err = bgenimpl.HandleCompatibility(tn, b, r, id); !ok {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, consumerAssignmentRIds, 1); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, consumerAssignment.Has_client, err = bstd.UnmarshalBool(n, b); err != nil {
            return
        }
    }
    if n, err = consumerAssignment.Client.NestedUnmarshal(n, b, consumerAssignmentRIds, 2); err != nil {
        return
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, consumerAssignmentRIds, 3); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, consumerAssignment.Created_unix_nano, err = bstd.UnmarshalInt64(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, consumerAssignmentRIds, 4); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, consumerAssignment.Name, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, consumerAssignmentRIds, 5); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, consumerAssignment.Stream, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, consumerAssignmentRIds, 6); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, consumerAssignment.Consumer_config, err = bstd.UnmarshalBytesCropped(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, consumerAssignmentRIds, 7); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, consumerAssignment.Has_group, err = bstd.UnmarshalBool(n, b); err != nil {
            return
        }
    }
    if n, err = consumerAssignment.Group.NestedUnmarshal(n, b, consumerAssignmentRIds, 8); err != nil {
        return
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, consumerAssignmentRIds, 9); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, consumerAssignment.Has_state, err = bstd.UnmarshalBool(n, b); err != nil {
            return
        }
    }
    if n, err = consumerAssignment.State.NestedUnmarshal(n, b, consumerAssignmentRIds, 10); err != nil {
        return
    }
    n += 2
    return
}

// UnmarshalPlain - ConsumerAssignment
func (consumerAssignment *ConsumerAssignment) UnmarshalPlain(tn int, b []byte) (n int, err error) {
    n = tn
    if n, consumerAssignment.Has_client, err = bstd.UnmarshalBool(n, b); err != nil {
        return
    }
    if n, err = consumerAssignment.Client.UnmarshalPlain(n, b); err != nil {
        return
    }
    if n, consumerAssignment.Created_unix_nano, err = bstd.UnmarshalInt64(n, b); err != nil {
        return
    }
    if n, consumerAssignment.Name, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, consumerAssignment.Stream, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, consumerAssignment.Consumer_config, err = bstd.UnmarshalBytesCropped(n, b); err != nil {
        return
    }
    if n, consumerAssignment.Has_group, err = bstd.UnmarshalBool(n, b); err != nil {
        return
    }
    if n, err = consumerAssignment.Group.UnmarshalPlain(n, b); err != nil {
        return
    }
    if n, consumerAssignment.Has_state, err = bstd.UnmarshalBool(n, b); err != nil {
        return
    }
    if n, err = consumerAssignment.State.UnmarshalPlain(n, b); err != nil {
        return
    }
    return
}

// Struct - ClientInfo
type ClientInfo struct {
    Has_start bool
    Start_unix_nano int64
    Host string
    Id uint64
    Account string
    Service string
    User string
    Name string
    Lang string
    Version string
    Rtt_nano int64
    Server string
    Cluster string
    Alternates []string
    Has_stop bool
    Stop_unix_nano int64
    Jwt string
    Issuer_key string
    Name_tag string
    Tags []string
    Kind string
    Client_type string
    Mqtt_client string
    Nonce string
}

// Reserved Ids - ClientInfo
var clientInfoRIds = []uint16{}

// Size - ClientInfo
func (clientInfo *ClientInfo) Size() int {
    return clientInfo.NestedSize(0)
}

// Nested Size - ClientInfo
func (clientInfo *ClientInfo) NestedSize(id uint16) (s int) {
    s += bstd.SizeBool() + 2
    s += bstd.SizeInt64() + 2
    s += bstd.SizeString(clientInfo.Host) + 2
    s += bstd.SizeUint64() + 2
    s += bstd.SizeString(clientInfo.Account) + 2
    s += bstd.SizeString(clientInfo.Service) + 2
    s += bstd.SizeString(clientInfo.User) + 2
    s += bstd.SizeString(clientInfo.Name) + 2
    s += bstd.SizeString(clientInfo.Lang) + 2
    s += bstd.SizeString(clientInfo.Version) + 2
    s += bstd.SizeInt64() + 2
    s += bstd.SizeString(clientInfo.Server) + 2
    s += bstd.SizeString(clientInfo.Cluster) + 2
    s += bstd.SizeSlice(clientInfo.Alternates, bstd.SizeString) + 2
    s += bstd.SizeBool() + 2
    s += bstd.SizeInt64() + 2
    s += bstd.SizeString(clientInfo.Jwt) + 2
    s += bstd.SizeString(clientInfo.Issuer_key) + 2
    s += bstd.SizeString(clientInfo.Name_tag) + 2
    s += bstd.SizeSlice(clientInfo.Tags, bstd.SizeString) + 2
    s += bstd.SizeString(clientInfo.Kind) + 2
    s += bstd.SizeString(clientInfo.Client_type) + 2
    s += bstd.SizeString(clientInfo.Mqtt_client) + 2
    s += bstd.SizeString(clientInfo.Nonce) + 2

    if id > 255 {
        s += 5
        return
    }
    s += 4
    return
}

// SizePlain - ClientInfo
func (clientInfo *ClientInfo) SizePlain() (s int) {
    s += bstd.SizeBool()
    s += bstd.SizeInt64()
    s += bstd.SizeString(clientInfo.Host)
    s += bstd.SizeUint64()
    s += bstd.SizeString(clientInfo.Account)
    s += bstd.SizeString(clientInfo.Service)
    s += bstd.SizeString(clientInfo.User)
    s += bstd.SizeString(clientInfo.Name)
    s += bstd.SizeString(clientInfo.Lang)
    s += bstd.SizeString(clientInfo.Version)
    s += bstd.SizeInt64()
    s += bstd.SizeString(clientInfo.Server)
    s += bstd.SizeString(clientInfo.Cluster)
    s += bstd.SizeSlice(clientInfo.Alternates, bstd.SizeString)
    s += bstd.SizeBool()
    s += bstd.SizeInt64()
    s += bstd.SizeString(clientInfo.Jwt)
    s += bstd.SizeString(clientInfo.Issuer_key)
    s += bstd.SizeString(clientInfo.Name_tag)
    s += bstd.SizeSlice(clientInfo.Tags, bstd.SizeString)
    s += bstd.SizeString(clientInfo.Kind)
    s += bstd.SizeString(clientInfo.Client_type)
    s += bstd.SizeString(clientInfo.Mqtt_client)
    s += bstd.SizeString(clientInfo.Nonce)
    return
}

// Marshal - ClientInfo
func (clientInfo *ClientInfo) Marshal(b []byte) {
    clientInfo.NestedMarshal(0, b, 0)
}

// Nested Marshal - ClientInfo
func (clientInfo *ClientInfo) NestedMarshal(tn int, b []byte, id uint16) (n int) {
    n = bgenimpl.MarshalTag(tn, b, bgenimpl.Container, id)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed8, 1)
    n = bstd.MarshalBool(n, b, clientInfo.Has_start)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed64, 2)
    n = bstd.MarshalInt64(n, b, clientInfo.Start_unix_nano)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 3)
    n = bstd.MarshalString(n, b, clientInfo.Host)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed64, 4)
    n = bstd.MarshalUint64(n, b, clientInfo.Id)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 5)
    n = bstd.MarshalString(n, b, clientInfo.Account)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 6)
    n = bstd.MarshalString(n, b, clientInfo.Service)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 7)
    n = bstd.MarshalString(n, b, clientInfo.User)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 8)
    n = bstd.MarshalString(n, b, clientInfo.Name)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 9)
    n = bstd.MarshalString(n, b, clientInfo.Lang)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 10)
    n = bstd.MarshalString(n, b, clientInfo.Version)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed64, 11)
    n = bstd.MarshalInt64(n, b, clientInfo.Rtt_nano)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 12)
    n = bstd.MarshalString(n, b, clientInfo.Server)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 13)
    n = bstd.MarshalString(n, b, clientInfo.Cluster)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.ArrayMap, 14)
    n = bstd.MarshalSlice(n, b, clientInfo.Alternates, bstd.MarshalString)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed8, 15)
    n = bstd.MarshalBool(n, b, clientInfo.Has_stop)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed64, 16)
    n = bstd.MarshalInt64(n, b, clientInfo.Stop_unix_nano)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 17)
    n = bstd.MarshalString(n, b, clientInfo.Jwt)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 18)
    n = bstd.MarshalString(n, b, clientInfo.Issuer_key)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 19)
    n = bstd.MarshalString(n, b, clientInfo.Name_tag)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.ArrayMap, 20)
    n = bstd.MarshalSlice(n, b, clientInfo.Tags, bstd.MarshalString)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 21)
    n = bstd.MarshalString(n, b, clientInfo.Kind)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 22)
    n = bstd.MarshalString(n, b, clientInfo.Client_type)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 23)
    n = bstd.MarshalString(n, b, clientInfo.Mqtt_client)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 24)
    n = bstd.MarshalString(n, b, clientInfo.Nonce)

    n += 2
    b[n-2] = 1
    b[n-1] = 1
    return
}

// MarshalPlain - ClientInfo
func (clientInfo *ClientInfo) MarshalPlain(tn int, b []byte) (n int) {
    n = tn
    n = bstd.MarshalBool(n, b, clientInfo.Has_start)
    n = bstd.MarshalInt64(n, b, clientInfo.Start_unix_nano)
    n = bstd.MarshalString(n, b, clientInfo.Host)
    n = bstd.MarshalUint64(n, b, clientInfo.Id)
    n = bstd.MarshalString(n, b, clientInfo.Account)
    n = bstd.MarshalString(n, b, clientInfo.Service)
    n = bstd.MarshalString(n, b, clientInfo.User)
    n = bstd.MarshalString(n, b, clientInfo.Name)
    n = bstd.MarshalString(n, b, clientInfo.Lang)
    n = bstd.MarshalString(n, b, clientInfo.Version)
    n = bstd.MarshalInt64(n, b, clientInfo.Rtt_nano)
    n = bstd.MarshalString(n, b, clientInfo.Server)
    n = bstd.MarshalString(n, b, clientInfo.Cluster)
    n = bstd.MarshalSlice(n, b, clientInfo.Alternates, bstd.MarshalString)
    n = bstd.MarshalBool(n, b, clientInfo.Has_stop)
    n = bstd.MarshalInt64(n, b, clientInfo.Stop_unix_nano)
    n = bstd.MarshalString(n, b, clientInfo.Jwt)
    n = bstd.MarshalString(n, b, clientInfo.Issuer_key)
    n = bstd.MarshalString(n, b, clientInfo.Name_tag)
    n = bstd.MarshalSlice(n, b, clientInfo.Tags, bstd.MarshalString)
    n = bstd.MarshalString(n, b, clientInfo.Kind)
    n = bstd.MarshalString(n, b, clientInfo.Client_type)
    n = bstd.MarshalString(n, b, clientInfo.Mqtt_client)
    n = bstd.MarshalString(n, b, clientInfo.Nonce)
    return n
}

// Unmarshal - ClientInfo
func (clientInfo *ClientInfo) Unmarshal(b []byte) (err error) {
    _, err = clientInfo.NestedUnmarshal(0, b, []uint16{}, 0)
    return
}

// Nested Unmarshal - ClientInfo
func (clientInfo *ClientInfo) NestedUnmarshal(tn int, b []byte, r []uint16, id uint16) (n int, err error) {
    var ok bool
    if n, ok, err = bgenimpl.HandleCompatibility(tn, b, r, id); !ok {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 1); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Has_start, err = bstd.UnmarshalBool(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 2); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Start_unix_nano, err = bstd.UnmarshalInt64(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 3); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Host, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 4); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Id, err = bstd.UnmarshalUint64(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 5); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Account, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 6); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Service, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 7); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.User, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 8); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Name, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 9); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Lang, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 10); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Version, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 11); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Rtt_nano, err = bstd.UnmarshalInt64(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 12); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Server, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 13); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Cluster, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 14); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Alternates, err = bstd.UnmarshalSlice[string](n, b, bstd.UnmarshalString); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 15); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Has_stop, err = bstd.UnmarshalBool(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 16); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Stop_unix_nano, err = bstd.UnmarshalInt64(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 17); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Jwt, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 18); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Issuer_key, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 19); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Name_tag, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 20); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Tags, err = bstd.UnmarshalSlice[string](n, b, bstd.UnmarshalString); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 21); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Kind, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 22); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Client_type, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 23); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Mqtt_client, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, clientInfoRIds, 24); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, clientInfo.Nonce, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    n += 2
    return
}

// UnmarshalPlain - ClientInfo
func (clientInfo *ClientInfo) UnmarshalPlain(tn int, b []byte) (n int, err error) {
    n = tn
    if n, clientInfo.Has_start, err = bstd.UnmarshalBool(n, b); err != nil {
        return
    }
    if n, clientInfo.Start_unix_nano, err = bstd.UnmarshalInt64(n, b); err != nil {
        return
    }
    if n, clientInfo.Host, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, clientInfo.Id, err = bstd.UnmarshalUint64(n, b); err != nil {
        return
    }
    if n, clientInfo.Account, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, clientInfo.Service, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, clientInfo.User, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, clientInfo.Name, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, clientInfo.Lang, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, clientInfo.Version, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, clientInfo.Rtt_nano, err = bstd.UnmarshalInt64(n, b); err != nil {
        return
    }
    if n, clientInfo.Server, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, clientInfo.Cluster, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, clientInfo.Alternates, err = bstd.UnmarshalSlice[string](n, b, bstd.UnmarshalString); err != nil {
        return
    }
    if n, clientInfo.Has_stop, err = bstd.UnmarshalBool(n, b); err != nil {
        return
    }
    if n, clientInfo.Stop_unix_nano, err = bstd.UnmarshalInt64(n, b); err != nil {
        return
    }
    if n, clientInfo.Jwt, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, clientInfo.Issuer_key, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, clientInfo.Name_tag, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, clientInfo.Tags, err = bstd.UnmarshalSlice[string](n, b, bstd.UnmarshalString); err != nil {
        return
    }
    if n, clientInfo.Kind, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, clientInfo.Client_type, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, clientInfo.Mqtt_client, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, clientInfo.Nonce, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    return
}

// Struct - RaftGroup
type RaftGroup struct {
    Name string
    Peers []string
    Storage_type int32
    Cluster string
    Preferred string
    Scale_up bool
}

// Reserved Ids - RaftGroup
var raftGroupRIds = []uint16{}

// Size - RaftGroup
func (raftGroup *RaftGroup) Size() int {
    return raftGroup.NestedSize(0)
}

// Nested Size - RaftGroup
func (raftGroup *RaftGroup) NestedSize(id uint16) (s int) {
    s += bstd.SizeString(raftGroup.Name) + 2
    s += bstd.SizeSlice(raftGroup.Peers, bstd.SizeString) + 2
    s += bstd.SizeInt32() + 2
    s += bstd.SizeString(raftGroup.Cluster) + 2
    s += bstd.SizeString(raftGroup.Preferred) + 2
    s += bstd.SizeBool() + 2

    if id > 255 {
        s += 5
        return
    }
    s += 4
    return
}

// SizePlain - RaftGroup
func (raftGroup *RaftGroup) SizePlain() (s int) {
    s += bstd.SizeString(raftGroup.Name)
    s += bstd.SizeSlice(raftGroup.Peers, bstd.SizeString)
    s += bstd.SizeInt32()
    s += bstd.SizeString(raftGroup.Cluster)
    s += bstd.SizeString(raftGroup.Preferred)
    s += bstd.SizeBool()
    return
}

// Marshal - RaftGroup
func (raftGroup *RaftGroup) Marshal(b []byte) {
    raftGroup.NestedMarshal(0, b, 0)
}

// Nested Marshal - RaftGroup
func (raftGroup *RaftGroup) NestedMarshal(tn int, b []byte, id uint16) (n int) {
    n = bgenimpl.MarshalTag(tn, b, bgenimpl.Container, id)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 1)
    n = bstd.MarshalString(n, b, raftGroup.Name)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.ArrayMap, 2)
    n = bstd.MarshalSlice(n, b, raftGroup.Peers, bstd.MarshalString)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed32, 3)
    n = bstd.MarshalInt32(n, b, raftGroup.Storage_type)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 4)
    n = bstd.MarshalString(n, b, raftGroup.Cluster)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 5)
    n = bstd.MarshalString(n, b, raftGroup.Preferred)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed8, 6)
    n = bstd.MarshalBool(n, b, raftGroup.Scale_up)

    n += 2
    b[n-2] = 1
    b[n-1] = 1
    return
}

// MarshalPlain - RaftGroup
func (raftGroup *RaftGroup) MarshalPlain(tn int, b []byte) (n int) {
    n = tn
    n = bstd.MarshalString(n, b, raftGroup.Name)
    n = bstd.MarshalSlice(n, b, raftGroup.Peers, bstd.MarshalString)
    n = bstd.MarshalInt32(n, b, raftGroup.Storage_type)
    n = bstd.MarshalString(n, b, raftGroup.Cluster)
    n = bstd.MarshalString(n, b, raftGroup.Preferred)
    n = bstd.MarshalBool(n, b, raftGroup.Scale_up)
    return n
}

// Unmarshal - RaftGroup
func (raftGroup *RaftGroup) Unmarshal(b []byte) (err error) {
    _, err = raftGroup.NestedUnmarshal(0, b, []uint16{}, 0)
    return
}

// Nested Unmarshal - RaftGroup
func (raftGroup *RaftGroup) NestedUnmarshal(tn int, b []byte, r []uint16, id uint16) (n int, err error) {
    var ok bool
    if n, ok, err = bgenimpl.HandleCompatibility(tn, b, r, id); !ok {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, raftGroupRIds, 1); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, raftGroup.Name, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, raftGroupRIds, 2); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, raftGroup.Peers, err = bstd.UnmarshalSlice[string](n, b, bstd.UnmarshalString); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, raftGroupRIds, 3); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, raftGroup.Storage_type, err = bstd.UnmarshalInt32(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, raftGroupRIds, 4); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, raftGroup.Cluster, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, raftGroupRIds, 5); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, raftGroup.Preferred, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, raftGroupRIds, 6); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, raftGroup.Scale_up, err = bstd.UnmarshalBool(n, b); err != nil {
            return
        }
    }
    n += 2
    return
}

// UnmarshalPlain - RaftGroup
func (raftGroup *RaftGroup) UnmarshalPlain(tn int, b []byte) (n int, err error) {
    n = tn
    if n, raftGroup.Name, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, raftGroup.Peers, err = bstd.UnmarshalSlice[string](n, b, bstd.UnmarshalString); err != nil {
        return
    }
    if n, raftGroup.Storage_type, err = bstd.UnmarshalInt32(n, b); err != nil {
        return
    }
    if n, raftGroup.Cluster, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, raftGroup.Preferred, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, raftGroup.Scale_up, err = bstd.UnmarshalBool(n, b); err != nil {
        return
    }
    return
}

// Struct - ConsumerState
type ConsumerState struct {
    Delivered SequencePair
    Ack_floor SequencePair
    Pending map[uint64]PendingEntry
    Redelivered map[uint64]uint64
}

// Reserved Ids - ConsumerState
var consumerStateRIds = []uint16{}

// Size - ConsumerState
func (consumerState *ConsumerState) Size() int {
    return consumerState.NestedSize(0)
}

// Nested Size - ConsumerState
func (consumerState *ConsumerState) NestedSize(id uint16) (s int) {
    s += consumerState.Delivered.NestedSize(1)
    s += consumerState.Ack_floor.NestedSize(2)
    s += bstd.SizeMap(consumerState.Pending, bstd.SizeUint64, func (s PendingEntry) int { return s.SizePlain() }) + 2
    s += bstd.SizeMap(consumerState.Redelivered, bstd.SizeUint64, bstd.SizeUint64) + 2

    if id > 255 {
        s += 5
        return
    }
    s += 4
    return
}

// SizePlain - ConsumerState
func (consumerState *ConsumerState) SizePlain() (s int) {
    s += consumerState.Delivered.SizePlain()
    s += consumerState.Ack_floor.SizePlain()
    s += bstd.SizeMap(consumerState.Pending, bstd.SizeUint64, func (s PendingEntry) int { return s.SizePlain() })
    s += bstd.SizeMap(consumerState.Redelivered, bstd.SizeUint64, bstd.SizeUint64)
    return
}

// Marshal - ConsumerState
func (consumerState *ConsumerState) Marshal(b []byte) {
    consumerState.NestedMarshal(0, b, 0)
}

// Nested Marshal - ConsumerState
func (consumerState *ConsumerState) NestedMarshal(tn int, b []byte, id uint16) (n int) {
    n = bgenimpl.MarshalTag(tn, b, bgenimpl.Container, id)
    n = consumerState.Delivered.NestedMarshal(n, b, 1)
    n = consumerState.Ack_floor.NestedMarshal(n, b, 2)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.ArrayMap, 3)
    n = bstd.MarshalMap(n, b, consumerState.Pending, bstd.MarshalUint64, func (n int, b []byte, s PendingEntry) int { return s.MarshalPlain(n, b) })
    n = bgenimpl.MarshalTag(n, b, bgenimpl.ArrayMap, 4)
    n = bstd.MarshalMap(n, b, consumerState.Redelivered, bstd.MarshalUint64, bstd.MarshalUint64)

    n += 2
    b[n-2] = 1
    b[n-1] = 1
    return
}

// MarshalPlain - ConsumerState
func (consumerState *ConsumerState) MarshalPlain(tn int, b []byte) (n int) {
    n = tn
    n = consumerState.Delivered.MarshalPlain(n, b)
    n = consumerState.Ack_floor.MarshalPlain(n, b)
    n = bstd.MarshalMap(n, b, consumerState.Pending, bstd.MarshalUint64, func (n int, b []byte, s PendingEntry) int { return s.MarshalPlain(n, b) })
    n = bstd.MarshalMap(n, b, consumerState.Redelivered, bstd.MarshalUint64, bstd.MarshalUint64)
    return n
}

// Unmarshal - ConsumerState
func (consumerState *ConsumerState) Unmarshal(b []byte) (err error) {
    _, err = consumerState.NestedUnmarshal(0, b, []uint16{}, 0)
    return
}

// Nested Unmarshal - ConsumerState
func (consumerState *ConsumerState) NestedUnmarshal(tn int, b []byte, r []uint16, id uint16) (n int, err error) {
    var ok bool
    if n, ok, err = bgenimpl.HandleCompatibility(tn, b, r, id); !ok {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if n, err = consumerState.Delivered.NestedUnmarshal(n, b, consumerStateRIds, 1); err != nil {
        return
    }
    if n, err = consumerState.Ack_floor.NestedUnmarshal(n, b, consumerStateRIds, 2); err != nil {
        return
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, consumerStateRIds, 3); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, consumerState.Pending, err = bstd.UnmarshalMap[uint64, PendingEntry](n, b, bstd.UnmarshalUint64, func (n int, b []byte, s *PendingEntry) (int, error) { return s.UnmarshalPlain(n, b) }); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, consumerStateRIds, 4); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, consumerState.Redelivered, err = bstd.UnmarshalMap[uint64, uint64](n, b, bstd.UnmarshalUint64, bstd.UnmarshalUint64); err != nil {
            return
        }
    }
    n += 2
    return
}

// UnmarshalPlain - ConsumerState
func (consumerState *ConsumerState) UnmarshalPlain(tn int, b []byte) (n int, err error) {
    n = tn
    if n, err = consumerState.Delivered.UnmarshalPlain(n, b); err != nil {
        return
    }
    if n, err = consumerState.Ack_floor.UnmarshalPlain(n, b); err != nil {
        return
    }
    if n, consumerState.Pending, err = bstd.UnmarshalMap[uint64, PendingEntry](n, b, bstd.UnmarshalUint64, func (n int, b []byte, s *PendingEntry) (int, error) { return s.UnmarshalPlain(n, b) }); err != nil {
        return
    }
    if n, consumerState.Redelivered, err = bstd.UnmarshalMap[uint64, uint64](n, b, bstd.UnmarshalUint64, bstd.UnmarshalUint64); err != nil {
        return
    }
    return
}

// Struct - SequencePair
type SequencePair struct {
    Consumer uint64
    Stream uint64
}

// Reserved Ids - SequencePair
var sequencePairRIds = []uint16{}

// Size - SequencePair
func (sequencePair *SequencePair) Size() int {
    return sequencePair.NestedSize(0)
}

// Nested Size - SequencePair
func (sequencePair *SequencePair) NestedSize(id uint16) (s int) {
    s += bstd.SizeUint64() + 2
    s += bstd.SizeUint64() + 2

    if id > 255 {
        s += 5
        return
    }
    s += 4
    return
}

// SizePlain - SequencePair
func (sequencePair *SequencePair) SizePlain() (s int) {
    s += bstd.SizeUint64()
    s += bstd.SizeUint64()
    return
}

// Marshal - SequencePair
func (sequencePair *SequencePair) Marshal(b []byte) {
    sequencePair.NestedMarshal(0, b, 0)
}

// Nested Marshal - SequencePair
func (sequencePair *SequencePair) NestedMarshal(tn int, b []byte, id uint16) (n int) {
    n = bgenimpl.MarshalTag(tn, b, bgenimpl.Container, id)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed64, 1)
    n = bstd.MarshalUint64(n, b, sequencePair.Consumer)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed64, 2)
    n = bstd.MarshalUint64(n, b, sequencePair.Stream)

    n += 2
    b[n-2] = 1
    b[n-1] = 1
    return
}

// MarshalPlain - SequencePair
func (sequencePair *SequencePair) MarshalPlain(tn int, b []byte) (n int) {
    n = tn
    n = bstd.MarshalUint64(n, b, sequencePair.Consumer)
    n = bstd.MarshalUint64(n, b, sequencePair.Stream)
    return n
}

// Unmarshal - SequencePair
func (sequencePair *SequencePair) Unmarshal(b []byte) (err error) {
    _, err = sequencePair.NestedUnmarshal(0, b, []uint16{}, 0)
    return
}

// Nested Unmarshal - SequencePair
func (sequencePair *SequencePair) NestedUnmarshal(tn int, b []byte, r []uint16, id uint16) (n int, err error) {
    var ok bool
    if n, ok, err = bgenimpl.HandleCompatibility(tn, b, r, id); !ok {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, sequencePairRIds, 1); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, sequencePair.Consumer, err = bstd.UnmarshalUint64(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, sequencePairRIds, 2); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, sequencePair.Stream, err = bstd.UnmarshalUint64(n, b); err != nil {
            return
        }
    }
    n += 2
    return
}

// UnmarshalPlain - SequencePair
func (sequencePair *SequencePair) UnmarshalPlain(tn int, b []byte) (n int, err error) {
    n = tn
    if n, sequencePair.Consumer, err = bstd.UnmarshalUint64(n, b); err != nil {
        return
    }
    if n, sequencePair.Stream, err = bstd.UnmarshalUint64(n, b); err != nil {
        return
    }
    return
}

// Struct - PendingEntry
type PendingEntry struct {
    Sequence uint64
    Timestamp int64
}

// Reserved Ids - PendingEntry
var pendingEntryRIds = []uint16{}

// Size - PendingEntry
func (pendingEntry *PendingEntry) Size() int {
    return pendingEntry.NestedSize(0)
}

// Nested Size - PendingEntry
func (pendingEntry *PendingEntry) NestedSize(id uint16) (s int) {
    s += bstd.SizeUint64() + 2
    s += bstd.SizeInt64() + 2

    if id > 255 {
        s += 5
        return
    }
    s += 4
    return
}

// SizePlain - PendingEntry
func (pendingEntry *PendingEntry) SizePlain() (s int) {
    s += bstd.SizeUint64()
    s += bstd.SizeInt64()
    return
}

// Marshal - PendingEntry
func (pendingEntry *PendingEntry) Marshal(b []byte) {
    pendingEntry.NestedMarshal(0, b, 0)
}

// Nested Marshal - PendingEntry
func (pendingEntry *PendingEntry) NestedMarshal(tn int, b []byte, id uint16) (n int) {
    n = bgenimpl.MarshalTag(tn, b, bgenimpl.Container, id)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed64, 1)
    n = bstd.MarshalUint64(n, b, pendingEntry.Sequence)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed64, 2)
    n = bstd.MarshalInt64(n, b, pendingEntry.Timestamp)

    n += 2
    b[n-2] = 1
    b[n-1] = 1
    return
}

// MarshalPlain - PendingEntry
func (pendingEntry *PendingEntry) MarshalPlain(tn int, b []byte) (n int) {
    n = tn
    n = bstd.MarshalUint64(n, b, pendingEntry.Sequence)
    n = bstd.MarshalInt64(n, b, pendingEntry.Timestamp)
    return n
}

// Unmarshal - PendingEntry
func (pendingEntry *PendingEntry) Unmarshal(b []byte) (err error) {
    _, err = pendingEntry.NestedUnmarshal(0, b, []uint16{}, 0)
    return
}

// Nested Unmarshal - PendingEntry
func (pendingEntry *PendingEntry) NestedUnmarshal(tn int, b []byte, r []uint16, id uint16) (n int, err error) {
    var ok bool
    if n, ok, err = bgenimpl.HandleCompatibility(tn, b, r, id); !ok {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, pendingEntryRIds, 1); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, pendingEntry.Sequence, err = bstd.UnmarshalUint64(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, pendingEntryRIds, 2); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, pendingEntry.Timestamp, err = bstd.UnmarshalInt64(n, b); err != nil {
            return
        }
    }
    n += 2
    return
}

// UnmarshalPlain - PendingEntry
func (pendingEntry *PendingEntry) UnmarshalPlain(tn int, b []byte) (n int, err error) {
    n = tn
    if n, pendingEntry.Sequence, err = bstd.UnmarshalUint64(n, b); err != nil {
        return
    }
    if n, pendingEntry.Timestamp, err = bstd.UnmarshalInt64(n, b); err != nil {
        return
    }
    return
}

